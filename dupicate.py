# -*- coding: utf-8 -*-
"""FinalESA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jlry-GFsGCYfcqQXB0c33AVINYiC-e-S
"""

import pandas as pd
import numpy as np
#from IPython.display import display, HTML
beetData = pd.read_csv('cabbage19-20.csv', parse_dates=['Date'], dayfirst=True)
beetData.head()









beetData["weekday"] = beetData["Date"].apply(lambda x: pd.to_datetime(x).date().weekday(), 1)
beetData.head(7)

beetData = beetData.loc[:, ~beetData.columns.str.contains('^Unnamed')]
beetData['Date']= pd.to_datetime(beetData['Date'], dayfirst=True, format = "%d/%m/%Y", errors='coerce')
 
# Check the format of 'Date' column
beetData.info()



# kolar - 5.0
# mysuru - 5.0
# cbp - 3.0
holiday = dict()
holiday["KOLAR"] = 5.0
holiday["CHICKBALLAPUR"] = 3.0
holiday["MYSURU"] = 5.0

"""***bold text***#Demo

"""

from numpy import isnan

def fill_weekdays(marketData):
  for i,j in marketData.iterrows():
    if(isnan(marketData.loc[i, 'weekday'])):
      marketData.loc[i,"weekday"] = (marketData.loc[i-1,"weekday"]+1)%7
  return marketData

def nan_rows(marketData):
  nanIndices = list()
  for i, j in marketData.iterrows():
      if pd.isnull(j['Modal']):
        nanIndices.append(i)
  return nanIndices

def croston_prep(marketData, market):
  marketData["Market"] = marketData["Market"].fillna(market)
  marketData["Min"] = marketData["Min"].fillna(0)
  marketData["Max"] = marketData["Max"].fillna(0)
  marketData["Modal"] = marketData["Modal"].fillna(0)
  return marketData

def marketChoice(data, market):
  marketData = pd.DataFrame()
  marketData = data[data['Market'] == market]
  marketData = marketData.drop(["Grade", "Arrivals", "Unit"], axis=1)
  marketData.set_index('Date', inplace=True)
  marketData = marketData.asfreq('D') 
  marketData = marketData.reset_index()
  marketData = fill_weekdays(marketData)
  # to_remove = holiday[market]
  # marketData = marketData[marketData["weekday"] != to_remove]
  return marketData

#@title #Croston's Model { display-mode: "form" }
def Croston(ts,extra_periods=1,alpha=0.4):
    d = np.array(ts) # Transform the input into a numpy array
    cols = len(d) # Historical period length
    d = np.append(d,[np.nan]*extra_periods) # Append np.nan into the demand array to cover future periods
    
    #level (a), periodicity(p) and forecast (f)
    a,p,f = np.full((3,cols+extra_periods),np.nan)
    q = 1 #periods since last demand observation
    
    # Initialization
    first_occurence = np.argmax(d[:cols]>0)
    a[0] = d[first_occurence]
    p[0] = 1 + first_occurence
    f[0] = a[0]/p[0]
# Create all the t+1 forecasts
    for t in range(0,cols):        
        if d[t] > 0:
            a[t+1] = alpha*d[t] + (1-alpha)*a[t] 
            p[t+1] = alpha*q + (1-alpha)*p[t]
            f[t+1] = a[t+1]/p[t+1]
            q = 1           
        else:
            a[t+1] = a[t]
            p[t+1] = p[t]
            f[t+1] = f[t]
            q += 1
       
    # Future Forecast 
    a[cols+1:cols+extra_periods] = a[cols]
    p[cols+1:cols+extra_periods] = p[cols]
    f[cols+1:cols+extra_periods] = f[cols]
                      
    df = pd.DataFrame.from_dict({"Demand":d,"Forecast":f,"Period":p,"Level":a,"Error":d-f})
    return df

def split_test_train(data, cultivation_time):
  x = len(data) - cultivation_time
  train_data = data[:x]
  test_data = data[x:]
  return train_data, test_data

from matplotlib import pyplot as plt
def plot_test_pred(frame, test_data):
  #plt.plot(frame, legend=True, label = "Predicted", color='red') # predicted
  #plt.plot(test_data, legend= True, label = "Test", color='green') # actual
  frame.plot(legend=True, label = "Predicted", color='red')
  test_data.plot(legend= True, label = "Test", color='green')
  plt.xlabel("Day Number")
  plt.ylabel("Modal Price")
  plt.show()

def plot_test_pred_train(test_data, train_data, pred):
  train_data.plot(legend=True,label='TRAIN')
  test_data.plot(legend=True,label='TEST',figsize=(12,8))
  pred.plot(legend=True,label='Prediction',figsize=(12,8))
  plt.ylabel("Modal price per Quintal")
  plt.xlabel("Days")

from sklearn.metrics import mean_squared_error, mean_absolute_error
from math import sqrt

def metrics(y_true, y_pred):
  mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100
  rmse = sqrt(mean_squared_error(y_pred, y_true.values))
  mse = mean_squared_error(y_pred, y_true.values)
  print("mape: ", mape)
  print("rmse: ", rmse)
  print("mse: ", mse)

from statsmodels.tsa.holtwinters import ExponentialSmoothing
#check is to see if you want to plot the results or not
# check == 0 is I DONT WANNA PLOT THE RESULTS
def Croston_HW(crop_data, market):
    print("CROP: ", crop_data.head())
    marketData = marketChoice(crop_data, market) # nan rows are made
    marketData = croston_prep(marketData, market)
    marketData["Modal"] = pd.to_numeric(marketData["Modal"])
    crostonData = Croston(marketData["Modal"],extra_periods=1,alpha=0.4)
    for ind in crostonData.index:
        if crostonData["Demand"][ind] == 0:
            crostonData["Demand"][ind] = crostonData["Forecast"][ind]
    crostonData = crostonData["Demand"]
    print("fhifhw", len(crostonData))
    train_data, test_data = split_test_train(crostonData, 10)
    test_data = test_data[0:len(test_data)-1]
    # train_data["Modal"] = pd.to_numeric(train_data["Modal"])
    # test_data["Modal"] = pd.to_numeric(test_data["Modal"])
    print("hehehh", (train_data.values==0).any())
    # print(train_data["Modal"])
    # for i in range(len(train_data)):
    #   if train_data.loc[i, "Modal"] == 0:
    #     print("yello")
    print(test_data)
    print(train_data)
    fit1 = ExponentialSmoothing(train_data,
                                seasonal_periods=328,   
                                trend='multiplicative', 
                                seasonal='mul', 
                                damped=True).fit(use_boxcox=True)
    frame = fit1.forecast(len(test_data))
    return frame
#   plot_test_pred(frame, test_data)
#   pred = pd.DataFrame
#   pred = frame 
#   plot_test_pred_train(test_data, train_data, pred[0:len(test_data)])
#   res = list(pred[0:len(test_data)])
#   metrics(test_data, res)


final = Croston_HW(beetData, "DODDABALLAPUR")
print(final)

#Croston_HW(beetData, "MYSURU", 313, 1)
#Croston_HW(beetData, "RAMANAGARA", 279, 1)
#Croston_HW(beetData, "KOLAR", 318, 1)
#Croston_HW(beetData, "CHICKBALLAPUR", 315, 1)
#Croston_HW(beetData, "DODDABALLAPUR", 328, 1)

#USAGE IS THE NUMBER OF DAYS THAT WE WANT TO PREDICT FOR 
def compare(beetData, date, usage):
  trial = marketChoice(beetData, "KOLAR")
  trial = trial[trial['Date'] == date]
  start_date = trial.index[0]
  td1, res1= Croston_HW(beetData, "MYSURU", 313, 0, usage)
  td2, res2 = Croston_HW(beetData, "KOLAR", 317, 0, usage)
  td3, res3 = Croston_HW(beetData, "RAMANAGARA", 279,0, usage)
  td4, res4 = Croston_HW(beetData, "CHICKBALLAPUR", 315, 0, usage)
  td5, res5 = Croston_HW(beetData, "DODDABALLAPUR", 328, 0, usage)
  #data = {'Market':['DODDABALLAPUR', 'CHICKBALLAPUR', 'RAMANAGARA', 'KOLAR','MYSURU' ], 'Actual':[td5[start_date], td4[start_date], td3[start_date],td2[start_date],td1[start_date]], 'Predicted':[res5[start_date-550], res4[start_date-550] , res3[start_date - 550], res2[start_date - 550], res1[start_date - 550]]}
  data = {'Market':['DODDABALLAPUR', 'CHICKBALLAPUR', 'RAMANAGARA', 'KOLAR','MYSURU' ],  'Price Per Quintal':[res5[start_date-550], res4[start_date-550] , res3[start_date - 550], res2[start_date - 550], res1[start_date - 550]]}
  comp = pd.DataFrame(data) 
  print("Date: " , date)
  #best_market = comp.loc[comp['Predicted'].idxmax()]['Market']
  #display(HTML(comp.to_html()))
  #print("\n")
  #print("Best Market for Highest Profit:", best_market)
  return data




# final = compare(beetData, "2020-07-06", 100)
# print(final)

data_long = {'Market': ['DODDABALLAPUR', 'CHICKBALLAPUR', 'RAMANAGARA', 'KOLAR', 'MYSURU'], 'Price Per Quintal': [770.938081384267, 934.3620734439446, 2476.3929601943305, 970.6745613832617, 769.9967510076508]}
data_short = {'Market': ['DODDABALLAPUR', 'CHICKBALLAPUR', 'RAMANAGARA', 'KOLAR', 'MYSURU'], 'Price Per Quintal': [575.0803351391806, 729.5032099627293, 1618.7507754000046, 833.2722102290707, 788.1581820392353]}




#mape:  12.584099422540609
#rmse:  124.73939812992202
#mse:  15559.917445815194
# 100 days - MYSURU - 343

#mape:  12.630523872233947
#rmse:  122.1987441130686
#mse:  14932.533062811219
#60 DAYS - MYSURU - 313

#mape:  14.05423018471916
#rmse:  411.63343610613606
#mse:  169442.0857205444
# 100 DAYS - RAMANAGARA --> 313

#mape:  23.243563643184395
#rmse:  452.09586968447474
#mse:  204390.67538576157
#60 days - ramanagara - 279

#550 2020-07-04  MYSURU    0.0    0.0    0.0      5.0