# -*- coding: utf-8 -*-
"""FinalESA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jlry-GFsGCYfcqQXB0c33AVINYiC-e-S
"""

import pandas as pd
import numpy as np
import json
from sklearn.utils.testing import ignore_warnings
from sklearn.exceptions import ConvergenceWarning
import requests
import geocoder
from geopy.geocoders import Nominatim
from get_holidays import in_holidays
import cgi
import datetime
from datetime import timedelta, date
from numpy import isnan

# from bottle import Bottle, template, request

# app = Bottle()
#import warnings
#from IPython.display import display, HTML
beetData = pd.read_csv('beet19-20.csv', parse_dates=['Date'], dayfirst=True)
beetData.head()









beetData["weekday"] = beetData["Date"].apply(lambda x: pd.to_datetime(x).date().weekday(), 1)
beetData.head(7)

beetData = beetData.loc[:, ~beetData.columns.str.contains('^Unnamed')]
beetData['Date']= pd.to_datetime(beetData['Date'], dayfirst=True, format = "%d/%m/%Y", errors='coerce')
 
# Check the format of 'Date' column
#beetData.info()



# kolar - 5.0
# mysuru - 5.0
# cbp - 3.0
holiday = dict()
holiday["KOLAR"] = 5.0
holiday["CHICKBALLAPUR"] = 3.0
holiday["MYSURU"] = 5.0

"""#Demo

"""



def fill_weekdays(marketData):
  for i,j in marketData.iterrows():
    if(isnan(marketData.loc[i, 'weekday'])):
      marketData.loc[i,"weekday"] = (marketData.loc[i-1,"weekday"]+1)%7
  return marketData

def nan_rows(marketData):
  nanIndices = list()
  for i, j in marketData.iterrows():
      if pd.isnull(j['Modal']):
        nanIndices.append(i)
  return nanIndices

def croston_prep(marketData, market):
  marketData["Market"] = marketData["Market"].fillna(market)
  marketData["Min"] = marketData["Min"].fillna(0)
  marketData["Max"] = marketData["Max"].fillna(0)
  marketData["Modal"] = marketData["Modal"].fillna(0)
  return marketData

def marketChoice(data, market):
  marketData = pd.DataFrame()
  marketData = data[data['Market'] == market]
  marketData = marketData.drop(["Grade", "Arrivals", "Unit"], axis=1)
  marketData.set_index('Date', inplace=True)
  marketData = marketData.asfreq('D') 
  marketData = marketData.reset_index()
  marketData = fill_weekdays(marketData)
  # to_remove = holiday[market]
  # marketData = marketData[marketData["weekday"] != to_remove]
  return marketData

#@title #Croston's Model { display-mode: "form" }
def Croston(ts,extra_periods=1,alpha=0.4):
    d = np.array(ts) # Transform the input into a numpy array
    cols = len(d) # Historical period length
    d = np.append(d,[np.nan]*extra_periods) # Append np.nan into the demand array to cover future periods
    
    #level (a), periodicity(p) and forecast (f)
    a,p,f = np.full((3,cols+extra_periods),np.nan)
    q = 1 #periods since last demand observation
    
    # Initialization
    first_occurence = np.argmax(d[:cols]>0)
    a[0] = d[first_occurence]
    p[0] = 1 + first_occurence
    f[0] = a[0]/p[0]
# Create all the t+1 forecasts
    for t in range(0,cols):        
        if d[t] > 0:
            a[t+1] = alpha*d[t] + (1-alpha)*a[t] 
            p[t+1] = alpha*q + (1-alpha)*p[t]
            f[t+1] = a[t+1]/p[t+1]
            q = 1           
        else:
            a[t+1] = a[t]
            p[t+1] = p[t]
            f[t+1] = f[t]
            q += 1
       
    # Future Forecast 
    a[cols+1:cols+extra_periods] = a[cols]
    p[cols+1:cols+extra_periods] = p[cols]
    f[cols+1:cols+extra_periods] = f[cols]
                      
    df = pd.DataFrame.from_dict({"Demand":d,"Forecast":f,"Period":p,"Level":a,"Error":d-f})
    return df

def split_test_train(data, cultivation_time):
  x = len(data) - cultivation_time
  train_data = data[:x]
  test_data = data[x:]
  return train_data, test_data

from matplotlib import pyplot as plt
def plot_test_pred(frame, test_data):
  #plt.plot(frame, legend=True, label = "Predicted", color='red') # predicted
  #plt.plot(test_data, legend= True, label = "Test", color='green') # actual
  frame.plot(legend=True, label = "Predicted", color='red')
  test_data.plot(legend= True, label = "Test", color='green')
  plt.xlabel("Day Number")
  plt.ylabel("Modal Price")
  plt.show()

def plot_test_pred_train(test_data, train_data, pred):
  train_data.plot(legend=True,label='TRAIN')
  test_data.plot(legend=True,label='TEST',figsize=(12,8))
  pred.plot(legend=True,label='Prediction',figsize=(12,8))
  plt.ylabel("Modal price per Quintal")
  plt.xlabel("Days")

from sklearn.metrics import mean_squared_error, mean_absolute_error
from math import sqrt

def metrics(y_true, y_pred):

  mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100
  rmse = sqrt(mean_squared_error(y_pred, y_true.values))
  mse = mean_squared_error(y_pred, y_true.values)
  #print("mape: ", mape)
  #print("rmse: ", rmse)
  #print("mse: ", mse)

from statsmodels.tsa.holtwinters import ExponentialSmoothing
@ignore_warnings(category=ConvergenceWarning)
def Croston_HW(crop_data, market, rand, check):
  marketData = marketChoice(crop_data, market) # nan rows are made
  marketData = croston_prep(marketData, market)
  marketData["Modal"] = pd.to_numeric(marketData["Modal"])
  crostonData = Croston(marketData["Modal"],extra_periods=1,alpha=0.4)
  for ind in crostonData.index:
    if crostonData["Demand"][ind] == 0:
      crostonData["Demand"][ind] = crostonData["Forecast"][ind]
  crostonData = crostonData["Demand"]
  
  train_data, test_data = split_test_train(crostonData, 60)
  test_data = test_data[0:len(test_data)-1]
  fit1 = ExponentialSmoothing(train_data,
                            seasonal_periods=rand,   
                            trend='multiplicative', 
                            seasonal='mul', 
                            damped=True).fit(use_boxcox=True)
  #10th july - 15th july 
  frame = fit1.forecast(len(test_data))
  pred = pd.DataFrame
  pred = frame 
  res = list(pred[0:len(test_data)])
  if(check == 1):
    plot_test_pred(frame, test_data)
    
    
    #plot_test_pred_train(test_data, train_data, pred[0:len(test_data)])
    #metrics(test_data, res)
  
  else:
    return test_data, res

data = {'Market': ['RAMANAGARA', 'KOLAR', 'MYSURU'], 'Price per Quintal': [2476.3929601943305, 970.6745613832617, 769.9967510076508]}
data_long_Beetroot= {'Market': ['DODDABALLAPUR', 'CHICKBALLAPUR', 'KOLAR', 'MYSURU'], 'Price Per Quintal': [771, 934, 971, 770]}
data_short = {'Market': ['DODDABALLAPUR', 'CHICKBALLAPUR', 'KOLAR', 'MYSURU'], 'Price Per Quintal': [575, 729, 833, 788]}
data_long_Cabbage = {'Market': ['DODDABALLAPUR', 'CHICKBALLAPUR', 'KOLAR', 'MYSURU'], 'Price Per Quintal': [410, 325, 360, 500]}
data_pick = {'Crop': ['Beetroot', 'Cabbage'], 'Price per Quintal': []}
def compare(beetData, date):
  print("reached")
  trial = marketChoice(beetData, "KOLAR")
  trial = trial[trial['Date'] == date]
  print(trial)
  start_date = trial.index[0]
  td1, res1= Croston_HW(beetData, "MYSURU", 313, 0)
  td2, res2 = Croston_HW(beetData, "KOLAR", 318, 0)
  td3, res3 = Croston_HW(beetData, "RAMANAGARA", 279,0)
  data = {'Market':['RAMANAGARA', 'KOLAR','MYSURU' ], 'Actual':[td3[start_date],td2[start_date],td1[start_date]], 'Predicted':[res3[start_date - 550], res2[start_date - 550], res1[start_date - 550]]}
  #comp = pd.DataFrame(data) 
  #print("Date: " , date)
  #best_market = comp.loc[comp['Predicted'].idxmax()]['Market']
  #display(HTML(comp.to_html()))
  #print("\n")
  #print("Best Market for Highest Profit:", best_market)
  return data,date

data = compare(beetData, "2020-07-06")
print(data)



#Chikballapur - 325
#Kolar - 360
#Mysuru - 500
#Doddaballapur -  410

#Croston_HW(beetData, "MYSURU", 313, 1)
#print(data)
#data = compare(beetData, "2020-07-06")
#Croston_HW(beetData, "RAMANAGARA", 279, 1)
#Croston_HW(beetData, "KOLAR", 318, 1)

#mysuru 313
#ramanagara 311

######## DEMO CODE #################


from flask import Flask, render_template, request
app = Flask(__name__)

@app.route('/', methods = ['GET'])
def intro():
      return render_template('intro.html')


date_1 = datetime.datetime(2021, 2 , 15)
#date_1 = datetime.datetime.strptime(start_date, "%m/%d/%y")
market_locs_demo = {"DODDABALLAPUR" : [13.2957, 77.5364], "CHICKBALLAPUR" : [13.4355, 77.7315], "KOLAR" : [13.1362, 78.1291], "MYSURU" : [12.2958, 76.6394]}
market_locs = {"BANGARPET" : [12.9924, 78.1768], "BINNY MILL (F&V)": [12.9709, 77.5664], "CHICKBALLAPUR" : [13.4355, 77.7315], "MYSURU" : [12.2958, 76.6394], "RAMANAGARA" : [12.7209, 77.2799], "CR_NAGARA": [12.4400, 76.3811],"DODDABALLAPUR" : [13.2957, 77.5364], "KOLAR" : [13.1362, 78.1291], "CHANNAPATNA" : [12.6518, 77.2086]}
@app.route('/send_data', methods = ['POST'])
def get_data_from_html():
        location = request.form['loc'] #user specified loc 
        
        if (location):
          geolocator = Nominatim(user_agent="app")
          location = geolocator.geocode(str(location))
          lat = str(location.latitude)
          longi = str(location.longitude)
          print(location)
        else:

          g = geocoder.ip('me')
          latlng = g.latlng
          lat = str(latlng[0])
          longi = str(latlng[1])
        #lat = str(13.1362)
        #longi = str(78.1291)
        #location = request.form['loc']

        crp = request.form['crop']
        amt = int(request.form['amount'])
        use_case = request.form['use_case']
        distances = {}
        
        for i in market_locs_demo:
          dest_long = str(market_locs_demo[i][1])
          dest_lat = str(market_locs_demo[i][0])

          r = requests.get(f"http://router.project-osrm.org/route/v1/car/" + longi + "," + lat + ";" + dest_long + "," + dest_lat + "?overview=false""")
          routes = json.loads(r.content)
          route_1 = routes.get("routes")[0]
          distance = route_1["legs"][0]["distance"]
          final_dist = int(distance/1000)
          distances[i] = final_dist

        final_prices = {}
        print('reached')
        if(crp == "Beetroot"):
          data_long = data_long_Beetroot
        else:
          data_long = data_long_Beetroot
        if (use_case == "short_term"):
          data = data_short
          end_date = date_1 + datetime.timedelta(days=10) 
        elif (use_case == "long_term"):
          data = data_long
          end_date = date_1 + datetime.timedelta(days=60) #add cultivation time
        else:
          final = []
          for i in data_pick["Crop"]:
            

            #print("data_long" + "_" + str(i))
            #data = dict("data_long" + "_" + str(i))
            if i == "Beetroot":
              data = data_long_Beetroot
            else:
              data = data_long_Cabbage
            data['Net Profit'] = []
            data["Season"] = []
            for j in market_locs_demo:
              if(amt < 500) :
                cost = 6
              elif(amt <1000):
                cost = 10
              else:
                cost = 15
              x = data['Market'].index(j)
              ppq = data['Price Per Quintal'][x]
              quintals = amt/100
              totcost = ppq * quintals
              logcost = cost * distances[j]
               

              
              final_prices[j] = int(ppq*(amt/100)) - int(cost*distances[j])

              seasonal_cost = 0.15*final_prices[j]
              data_pick["Season"].append(seasonal_cost)
              if in_holidays.get(end_date) != None:
                  final_prices[j] = 1.15 * final_prices[j]

              data['Net Profit'].append(final_prices[j])
            maxi = max(data['Net Profit'])
            print("Maxi:", maxi)
            #bestprice = data['Net Profit'].index(maxi)
            final.append(maxi)
            print(final)
            #best_market = data['Market'][bestprice]

          bestp = max(final)
          idx = final.index(bestp)
          best_crop = data_pick["Crop"][idx]
          for i in final:
            data_pick["Price per Quintal"].append(i)
          print(bestp)
          return render_template('compare.html', x = data_pick, best = best_crop)




        

        data['Net Profit'] = []
        data["Season"] = []
        #print("HELLLLLO")
        for j in market_locs_demo:
          if(amt < 500) :
            cost = 6
          elif(amt <1000):
            cost = 10
          else:
            cost = 15
          x = data['Market'].index(j)
          ppq = data['Price Per Quintal'][x]
          quintals = amt/100
          totcost = ppq * quintals
          logcost = cost * distances[j]

          
          final_prices[j] = int(ppq*(amt/100)) - int(cost*distances[j])
          
          if end_date in in_holidays:
              seasonal_cost = 0.15*final_prices[j]
              data["Season"].append(seasonal_cost)

              final_prices[j] = 1.15 * final_prices[j]
          else:
            data["Season"].append(0)


          data['Net Profit'].append(final_prices[j])
        
        #data['Net Profit'] = [final_prices['RAMANAGARA'], final_prices['KOLAR'], final_prices['MYSURU']]
        maxi = max(data['Net Profit'])
        bestprice = data['Net Profit'].index(maxi)
        best_market = data['Market'][bestprice]

        return render_template('index.html', x = data, best = best_market)
      
'''
Tiers:
500 and less (6) -> small
500 - 1000 (10) -> medium
1000 and more (15) -> large
'''
@app.route('/index', methods=['POST'])
def index():
  # crp = request.form['crop']
  # print ("crop " + crp)
  #   #return "Data sent. Please check your program log"
  return render_template('index.html', x = data)

'''@app.route('/my-link/')
def my_link():
  print ('I got clicked!')'''



if __name__ == '__main__':
  app.run(debug=True)








#mape:  12.584099422540609
#rmse:  124.73939812992202
#mse:  15559.917445815194
# 100 days - MYSURU - 343

#mape:  12.630523872233947
#rmse:  122.1987441130686
#mse:  14932.533062811219
#60 DAYS - MYSURU - 313

#mape:  14.05423018471916
#rmse:  411.63343610613606
#mse:  169442.0857205444
# 100 DAYS - RAMANAGARA --> 313

#mape:  23.243563643184395
#rmse:  452.09586968447474
#mse:  204390.67538576157
#60 days - ramanagara - 279

#550 2020-07-04  MYSURU    0.0    0.0    0.0      5.0