# -*- coding: utf-8 -*-
"""Copy of Copy of FinalESA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y5uDQC2tt4ZE1tC5oOke64ZwZaCpSa-5
"""

import pandas as pd
import numpy as np
from IPython.display import display, HTML
beetData = pd.read_csv('beet19-20.csv', parse_dates=['Date'], dayfirst=True)
beetData.head()









beetData["weekday"] = beetData["Date"].apply(lambda x: pd.to_datetime(x).date().weekday(), 1)
beetData.head(7)

beetData = beetData.loc[:, ~beetData.columns.str.contains('^Unnamed')]
beetData['Date']= pd.to_datetime(beetData['Date'], dayfirst=True, format = "%d/%m/%Y", errors='coerce')
 
# Check the format of 'Date' column
beetData.info()



# kolar - 5.0
# mysuru - 5.0
# cbp - 3.0
holiday = dict()
holiday["KOLAR"] = 5.0
holiday["CHICKBALLAPUR"] = 3.0
holiday["MYSURU"] = 5.0

"""#Demo

"""

from numpy import isnan

def fill_weekdays(marketData):
  for i,j in marketData.iterrows():
    if(isnan(marketData.loc[i, 'weekday'])):
      marketData.loc[i,"weekday"] = (marketData.loc[i-1,"weekday"]+1)%7
  return marketData

def nan_rows(marketData):
  nanIndices = list()
  for i, j in marketData.iterrows():
      if pd.isnull(j['Modal']):
        nanIndices.append(i)
  return nanIndices

def croston_prep(marketData, market):
  marketData["Market"] = marketData["Market"].fillna(market)
  marketData["Min"] = marketData["Min"].fillna(0)
  marketData["Max"] = marketData["Max"].fillna(0)
  marketData["Modal"] = marketData["Modal"].fillna(0)
  return marketData

def marketChoice(data, market):
  marketData = pd.DataFrame()
  marketData = data[data['Market'] == market]
  marketData = marketData.drop(["Grade", "Arrivals", "Unit"], axis=1)
  marketData.set_index('Date', inplace=True)
  marketData = marketData.asfreq('D') 
  marketData = marketData.reset_index()
  marketData = fill_weekdays(marketData)
  # to_remove = holiday[market]
  # marketData = marketData[marketData["weekday"] != to_remove]
  return marketData

#@title #Croston's Model { display-mode: "form" }
def Croston(ts,extra_periods=1,alpha=0.4):
    d = np.array(ts) # Transform the input into a numpy array
    cols = len(d) # Historical period length
    d = np.append(d,[np.nan]*extra_periods) # Append np.nan into the demand array to cover future periods
    
    #level (a), periodicity(p) and forecast (f)
    a,p,f = np.full((3,cols+extra_periods),np.nan)
    q = 1 #periods since last demand observation
    
    # Initialization
    first_occurence = np.argmax(d[:cols]>0)
    a[0] = d[first_occurence]
    p[0] = 1 + first_occurence
    f[0] = a[0]/p[0]
# Create all the t+1 forecasts
    for t in range(0,cols):        
        if d[t] > 0:
            a[t+1] = alpha*d[t] + (1-alpha)*a[t] 
            p[t+1] = alpha*q + (1-alpha)*p[t]
            f[t+1] = a[t+1]/p[t+1]
            q = 1           
        else:
            a[t+1] = a[t]
            p[t+1] = p[t]
            f[t+1] = f[t]
            q += 1
       
    # Future Forecast 
    a[cols+1:cols+extra_periods] = a[cols]
    p[cols+1:cols+extra_periods] = p[cols]
    f[cols+1:cols+extra_periods] = f[cols]
                      
    df = pd.DataFrame.from_dict({"Demand":d,"Forecast":f,"Period":p,"Level":a,"Error":d-f})
    return df

def split_test_train(data, cultivation_time):
  x = len(data) - cultivation_time
  train_data = data[:x]
  test_data = data[x:]
  return train_data, test_data

from matplotlib import pyplot as plt
def plot_test_pred(frame, test_data):
  #plt.plot(frame, legend=True, label = "Predicted", color='red') # predicted
  #plt.plot(test_data, legend= True, label = "Test", color='green') # actual
  frame.plot(legend=True, label = "Predicted", color='red')
  test_data.plot(legend= True, label = "Test", color='green')
  plt.xlabel("Day Number")
  plt.ylabel("Modal Price")
  plt.show()

def plot_test_pred_train(test_data, train_data, pred):
  train_data.plot(legend=True,label='TRAIN')
  test_data.plot(legend=True,label='TEST',figsize=(12,8))
  pred.plot(legend=True,label='Prediction',figsize=(12,8))
  plt.ylabel("Modal price per Quintal")
  plt.xlabel("Days")

from sklearn.metrics import mean_squared_error, mean_absolute_error
from math import sqrt

def metrics(y_true, y_pred):
  mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100
  rmse = sqrt(mean_squared_error(y_pred, y_true.values))
  mse = mean_squared_error(y_pred, y_true.values)
  print("mape: ", mape)
  print("rmse: ", rmse)
  print("mse: ", mse)

from statsmodels.tsa.holtwinters import ExponentialSmoothing
def Croston_HW(crop_data, market, rand, check):
  marketData = marketChoice(crop_data, market) # nan rows are made
  marketData = croston_prep(marketData, market)
  marketData["Modal"] = pd.to_numeric(marketData["Modal"])
  crostonData = Croston(marketData["Modal"],extra_periods=1,alpha=0.4)
  for ind in crostonData.index:
    if crostonData["Demand"][ind] == 0:
      crostonData["Demand"][ind] = crostonData["Forecast"][ind]
  crostonData = crostonData["Demand"]
  
  train_data, test_data = split_test_train(crostonData, 100)
  test_data = test_data[0:len(test_data)-1]
  fit1 = ExponentialSmoothing(train_data,
                            seasonal_periods=rand,   
                            trend='multiplicative', 
                            seasonal='mul', 
                            damped=True).fit(use_boxcox=True)
  frame = fit1.forecast(len(test_data))
  pred = pd.DataFrame
  pred = frame 
  res = list(pred[0:len(test_data)])
  if(check == 1):
    plot_test_pred(frame, test_data)
    
    
    plot_test_pred_train(test_data, train_data, pred[0:len(test_data)])
    metrics(test_data, res)
  
  else:
    return test_data, res

Croston_HW(beetData, "MYSURU", 313, 1)
#Croston_HW(beetData, "RAMANAGARA", 279, 1)
#Croston_HW(beetData, "KOLAR", 318, 1)

# def compare(beetData, date):
#   trial = marketChoice(beetData, "KOLAR")
#   trial = trial[trial['Date'] == date]
#   start_date = trial.index[0]
#   td1, res1= Croston_HW(beetData, "MYSURU", 313, 0)
#   td2, res2 = Croston_HW(beetData, "KOLAR", 318, 0)
#   td3, res3 = Croston_HW(beetData, "RAMANAGARA", 279,0)
#   data = {'Market':['RAMANAGARA', 'KOLAR','MYSURU' ], 'Actual':[td3[start_date],td2[start_date],td1[start_date]], 'Predicted':[res3[start_date - 550], res2[start_date - 550], res1[start_date - 550]]}
#   comp = pd.DataFrame(data) 
#   print("Date: " , date)
#   best_market = comp.loc[comp['Predicted'].idxmax()]['Market']
# #   display(HTML(comp.to_html()))
#   print("\n")
#   print("Best Market for Highest Profit:", best_market)

# compare(beetData, "2020-07-06")
